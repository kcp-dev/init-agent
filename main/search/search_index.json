{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":"<p>The kcp init-agent is a Kubernetes agent for initializing newly created workspaces by applying any number of Kubernetes objects in it. This can be used to ensure new clusters are automatically bootstrapped for certain purposes.</p> <p>Behind the scenes the init-agent uses kcp's <code>initializingworkspaces</code> virtual workspace to access new clusters before they have become ready (regular access to initializing clusters is forbidden in kcp). Once it has finished bootstrapping them, it removes an \"initializer\" from the cluster to signal to kcp that the cluster can become ready.</p> <p>The agent can source manifests for the objects to create from a variety of sources in theory, though currently only <code>InitTemplate</code> objects are implemented.</p>"},{"location":"#high-level-overview","title":"High-level Overview","text":"<p>To setup the agent, an administrator follows roughly these steps:</p> <ol> <li>Create a dedicated <code>WorkspaceType</code> for which the workspaces should be initialized. This new    <code>WorkspaceType</code> must have <code>spec.initializer</code> enabled to ensure kcp marks new workspaces as    not-yet-ready.</li> <li>Create an <code>InitTarget</code> object that connects the <code>WorkspaceType</code> with the init sources (as of now,    a list of <code>InitTemplate</code>s).</li> <li>Create a number of <code>InitTemplate</code> objects that contain Kubernetes manifests with Go templating    (similar to how Helm templates work).</li> <li>Run the init-agent by providing it a kubeconfig to access kcp and the name of the workspace where    the <code>InitTarget</code> objects reside.</li> </ol> <p>This concludes the initial setup. When users now create workspaces using the type created in step 1, the init-agent will perform the desired bootstrapping.</p>"},{"location":"#mode-of-operation","title":"Mode of Operation","text":"<p>The init-agent will continuously watch <code>InitTarget</code> objects in the <code>--config-workspace</code> it was started with. Each of these targets references exactly one <code>WorkspaceType</code> (there must be no overlaps, i.e. no two <code>InitTarget</code>s must point to the same <code>WorkspaceType</code>). One single init-agent instance can process many <code>InitTarget</code>s (optionally filtered by a label selector configured on the command line).</p> <p>For each <code>InitTarget</code>, it will spawn a multicluster-runtime manager that will process all clusters that use the <code>WorkspaceType</code> referenced in the target. Whenever a new cluster is created, it will be reconciled.</p> <p>Reconciliation involves getting the most recent version of the <code>InitTarget</code> and then fetching each of its init sources. Each source can provide any number of Kubernetes objects that are first sorted to ensure CRDs come first, then namespaces etc., and then applied to the newly created cluster.</p> <p>If a resource cannot be found, it is assumed that this is a transient error (for example when one init source creates an object using a resource provided by yet another mechanism (maybe another initializer, maybe a default APIBinding)). In these cases, reconciliation is retried after a few seconds.</p> <p>If all objects from all sources were applied cleanly, the initializer is removed from the <code>LogicalCluster</code>, which ends the agent's involvement and makes it \"disappear\" from the agent.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>TBD</p>"},{"location":"setup/","title":"Installing the Init Agent","text":"<p>This page describes the necessary steps to setup the Init Agent for an existing kcp installation.</p>"},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>A running kcp installation.</li> <li>A kubeconfig for kcp with the appropriate permissions to access its resources and the   <code>initializingworkspaces</code> virtual workspace.</li> </ul>"},{"location":"setup/#workspacetypes","title":"WorkspaceTypes","text":"<p>The basic mode of operation of the init-agent relies on kcp's initializers feature. For this feature, newly created workspaces are made inaccessible for users until all initializers (like finalizers, but in reverse) have been removed from the <code>LogicalCluster</code> that backs a workspace. Initializers are the cluster name + name of the <code>WorkspaceType</code>, for example <code>root:my-type</code> or <code>dhkgfj2gvrhbf:test-env</code>.</p> <p>Warning</p> <p>Since each <code>WorkspaceType</code> has exactly one (optional) initializer name, and it can only be removed once from a <code>LogicalCluster</code>, it's critical that you use dedicated workspace types for every bootstrapping purpose.</p> <p>This means there can only be exactly one <code>InitTarget</code> in the entire kcp installation that refers to a <code>WorkspaceType</code>. And only a single init-agent may process each <code>InitTarget</code>.</p> <p>Do not use the init-agent with kcp's own <code>WorkspaceTypes</code>, as this could interfere with kcp's core functionality.</p> <p>You can make use of <code>WorkspaceTypes</code> extending each other to combine more complex bootstrapping behaviour.</p> <p>The very first step to using the init-agent is to make sure you have your own, dedicated <code>WorkspaceTypes</code>. These can exist anywhere (any clusters) inside your kcp installation. It's important to enable <code>spec.initializer</code>, otherwise kcp will not add the type's initializer to newly created clusters.</p> <p>Let's create a sample type in <code>root:ws-types</code>:</p> <pre><code>apiVersion: tenancy.kcp.io/v1alpha1\nkind: WorkspaceType\nmetadata:\n  name: dev-environment\nspec:\n  # important, this must be set to true\n  initializer: true\n\n  defaultChildWorkspaceType:\n    name: universal\n    path: root\n\n  # extend the universal type to gain default kcp workspace behaviour\n  extend:\n    with:\n      - name: universal\n        path: root\n</code></pre> <p>Suppose your workspace <code>root:ws-types</code> is cluster <code>8924zrg2i5g4dr</code>, then this <code>WorkspaceType</code>'s initializer will be <code>8924zrg2i5g4dr:dev-environment</code>. The init-agent will automatically figure this out for you though.</p>"},{"location":"setup/#inittargets","title":"InitTargets","text":"<p>Now that the <code>WorkspaceTypes</code> are ready, it's time to configure them for the init-agent. To do so, we create <code>InitTarget</code> objects, which connect a type with a number of \"init source\". An init source is anything that provides manifests of Kubernetes objects.</p> <p>There can be up to one <code>InitTarget</code> in the entire kcp installation for any given <code>WorkspaceType</code>. The target and the type can be in different workspaces, however you must keep all <code>InitTargets</code> that should be processed by one init-agent in one workspace.</p> <p>Let's create a (dummy) <code>InitTarget</code> in <code>root:init-agent</code>:</p> <pre><code>apiVersion: initialization.kcp.io/v1alpha1\nkind: InitTarget\nmetadata:\n  name: init-dev-environment\nspec:\n  # reference the WorkspaceType to bootstrap\n  workspaceTypeRef:\n    path: root:ws-types\n    name: dev-environment\n\n  # list all the manifest sources\n  sources: []\n</code></pre>"},{"location":"setup/#init-sources","title":"Init Sources","text":"<p>Each <code>InitTarget</code> contains a list of init sources, which in turn are anything can provides a number of Kubernetes objects (usually in the form of YAML manifests). The mechanism is purposefully extensible, though at the moment only a limited number of such sources is implemented.</p>"},{"location":"setup/#inittemplate","title":"InitTemplate","text":"<p>This is the most basic init source. Init templates are Kubernetes objects that simply contain a single Go template string that is executed for each new cluster to be bootstrapped. This is very similar to how Helm chart templates work.</p> <p><code>InitTemplate</code> objects must reside in the same cluster as the <code>InitTargets</code> that are referring to them.</p> <p>Let's create a simple one, again in <code>root:ws-types</code>, that creates a namespace and then places a <code>ConfigMap</code> into it:</p> <pre><code>apiVersion: initialization.kcp.io/v1alpha1\nkind: InitTemplate\nmetadata:\n  name: cluster-info-configmap\nspec:\n  template: |\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      namespace: cluster-info\n      name: info\n    data:\n      cluster: \"{{ .ClusterName }}\"\n      workspace: \"{{ .ClusterPath }}\"\n\n    ---\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: cluster-info\n</code></pre> <p>Note how the namespace is listed after the <code>ConfigMap</code>. This is to demonstrate that after executing the template, the resulting objects are sorted by their hierarchy to ensure, for example, that CRDs are created before objects using them.</p> <p>Then update the <code>InitTarget</code> to refer to this template:</p> <pre><code>apiVersion: initialization.kcp.io/v1alpha1\nkind: InitTarget\nmetadata:\n  name: init-dev-environment\nspec:\n  #...\n\n  sources:\n    - template:\n        name: cluster-info-configmap\n</code></pre>"},{"location":"setup/#running-the-agent","title":"Running the Agent","text":""},{"location":"contributing/releasing/","title":"Release Process","text":"<p>The guide describes how to release a new version of the init-agent.</p>"},{"location":"contributing/releasing/#prerequisites","title":"Prerequisites","text":"<ol> <li>Have all desired changes merged and/or cherrypicked into the appropriate    release branch.</li> </ol>"},{"location":"contributing/releasing/#minor-release","title":"Minor Release","text":"<p>Minor releases (0.x) are tagged directly on the <code>main</code> branch and the <code>v0.X.0</code> tag represents where the corresponding <code>release/v0.X</code> branch branches off.</p> <ol> <li>Checkout the desired <code>main</code> branch commit.</li> <li>Tag the main module: <code>git tag -m \"version 0.X\" v0.X.0</code></li> <li>Tag the SDK module: <code>git tag -m \"SDK version 0.X\" sdk/v0.X.0</code></li> <li>Push the tags: <code>git push upstream v0.X.0 sdk/v0.X.0</code></li> <li>Create the release branch: <code>git checkout -B release-v0.X</code></li> <li>Push the release branch: <code>git push -u upstream release-v0.X</code></li> </ol> <p>Once the tag and branch have been pushed, the documentation has to be manually updated to include the new minor release.</p> <ol> <li>Navigate to https://github.com/kcp-dev/init-agent/actions/workflows/docs-gen-and-push.yaml</li> <li>Run the workflow manually on the new release branch.</li> </ol> <p>Within a few minutes of the action finishing, the new branch should show up on https://docs.kcp.io/init-agent/.</p>"},{"location":"contributing/releasing/#patch-releases","title":"Patch Releases","text":"<p>Patch releases (v0.x.y) are tagged with in a release branch.</p> <ol> <li>Checkout the desired <code>release/v0.X</code> branch commit.</li> <li>Tag the main module: <code>git tag -m \"version 0.X.Y\" v0.X.Y</code></li> <li>Tag the SDK module: <code>git tag -m \"SDK version 0.X.Y\" sdk/v0.X.Y</code></li> <li>Push the tags: <code>git push upstream v0.X.Y sdk/v0.X.Y</code></li> </ol>"},{"location":"init-sources/","title":"Init Sources","text":"<p>This chapter describes each available Init Source in greater detail.</p>"},{"location":"init-sources/#overview","title":"Overview","text":"<ul> <li>Init Templates are the simplest form of init source, making use of   a Kubernetes object to store the templates inside kcp.</li> </ul>"},{"location":"init-sources/inittemplate/","title":"Init Templates","text":"<p><code>InitTemplate</code> is a cluster-scoped resource that allows you to define Kubernetes manifests using Go templates. To produce the final list of manifests, the init-agent renders the Go template while injecting some templating data into it.</p> <p><code>InitTemplate</code> objects must reside in the same workspace as the <code>InitTargets</code> that reference them. One <code>InitTemplate</code> may be used by any number of <code>InitTargets</code>.</p>"},{"location":"init-sources/inittemplate/#resource-structure","title":"Resource Structure","text":"<p>An <code>InitTemplate</code> has a simple structure:</p> <pre><code>apiVersion: initialization.kcp.io/v1alpha1\nkind: InitTemplate\nmetadata:\n  name: my-init-template\nspec:\n  template: |\n    # Your Go template here, producing YAML manifests\n</code></pre> <p>The <code>spec.template</code> field contains a Go template that, when rendered, must produce valid YAML containing one or more Kubernetes manifests (separated by <code>---</code>).</p>"},{"location":"init-sources/inittemplate/#template-syntax","title":"Template Syntax","text":"<p>InitTemplates use standard Go templates. In addition to the built-in functions, all functions from sprig/v3 are available (e.g. <code>join</code>, <code>b64enc</code>, <code>default</code>, etc.).</p> <p>Warning</p> <p>Sprig contains functions that return random data, like <code>uuidv4</code>. These should be rarely, if ever, used in <code>InitTemplates</code>. Since bootstrapping can temporarily fail (for example if a certain resource is not yet available inside a new cluster), the init-agent might render the same templates on multiple occasions for the same cluster.</p> <p>Use these random functions only if you really do not care about idempotent templates.</p>"},{"location":"init-sources/inittemplate/#context-variables","title":"Context Variables","text":"<p>When the template is rendered, the following variables are available in the template context:</p> Name Type Description <code>ClusterName</code> <code>string</code> The internal cluster identifier (e.g. <code>\"34hg2j4gh24jdfgf\"</code>) of the workspace being initialized. <code>ClusterPath</code> <code>string</code> The workspace path (e.g. <code>\"root:customer:projectx\"</code>) of the workspace being initialized."},{"location":"init-sources/inittemplate/#example","title":"Example","text":"<p>The following example creates a ConfigMap in the initialized workspace that contains information about the workspace itself:</p> <pre><code>apiVersion: initialization.kcp.io/v1alpha1\nkind: InitTemplate\nmetadata:\n  name: workspace-info\nspec:\n  template: |\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: workspace-info\n    data:\n      clusterName: \"{{ .ClusterName }}\"\n      clusterPath: \"{{ .ClusterPath }}\"\n</code></pre> <p>You can also use sprig functions to transform values:</p> <pre><code>apiVersion: initialization.kcp.io/v1alpha1\nkind: InitTemplate\nmetadata:\n  name: workspace-setup\nspec:\n  template: |\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: workspace-metadata\n      labels:\n        workspace-hash: \"{{ .ClusterName | sha256sum | trunc 8 }}\"\n    data:\n      path: \"{{ .ClusterPath }}\"\n      pathSegments: \"{{ .ClusterPath | replace \":\" \",\" }}\"\n</code></pre> <p>To create multiple resources, separate them with <code>---</code>:</p> <pre><code>apiVersion: initialization.kcp.io/v1alpha1\nkind: InitTemplate\nmetadata:\n  name: multi-resource-init\nspec:\n  template: |\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: config-one\n    data:\n      workspace: \"{{ .ClusterPath }}\"\n\n    ---\n    apiVersion: v1\n    kind: ConfigMap\n    metadata:\n      name: config-two\n    data:\n      id: \"{{ .ClusterName }}\"\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>This chapter provides automatically generated references for the APIs provided by the kcp Init Agent.</p>"}]}